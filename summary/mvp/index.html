<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.jpg" />
    <link rel="stylesheet" href="/umi.79bb87e3.css" />
    <script>
      window.routerBase = "/";
    </script>
    <script>
      //! umi version: 3.3.3
    </script>
    <title>我在前端项目中使用了 MVP</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/summary/mvp" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.jpg&#x27;)" href="/">blog-doc</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span><a aria-current="page" class="active" href="/summary">Summary</a></span><span><a href="/practice">Practice</a></span><span><a href="/principle">Principle</a></span><span><a target="_blank" rel="noopener noreferrer" href="https://github.com/whistleyz">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></span></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.jpg&#x27;)" href="/"></a><h1>blog-doc</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a aria-current="page" class="active" href="/summary">Summary</a></li><li><a href="/practice">Practice</a></li><li><a href="/principle">Principle</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/whistleyz">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div><ul class="__dumi-default-menu-list"><li><a target="_blank" rel="noopener noreferrer">总结</a><ul><li><a href="/summary/extend_between_es6_and_es5"><span>ES6与ES5的类继承机制</span></a></li><li><a href="/summary/unit_test_miniapp"><span>小程序单元测试环境搭建</span></a></li><li><a aria-current="page" class="active" href="/summary/mvp"><span>我在前端项目中使用了 MVP</span></a></li><li><a href="/summary/bench_nodejs"><span>nodejs压力测试</span></a></li><li><a href="/summary/dynamic_form"><span>动态表单/表格</span></a></li><li><a href="/summary/sri"><span>Subresource Integrity</span></a></li></ul></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="概述" data-depth="2"><a href="/summary/mvp#概述"><span>概述</span></a></li><li title="MVP 简介" data-depth="3"><a href="/summary/mvp#mvp-简介"><span>MVP 简介</span></a></li><li title="背景" data-depth="3"><a href="/summary/mvp#背景"><span>背景</span></a></li><li title="实践" data-depth="2"><a href="/summary/mvp#实践"><span>实践</span></a></li><li title="需求" data-depth="3"><a href="/summary/mvp#需求"><span>需求</span></a></li><li title="实现" data-depth="3"><a href="/summary/mvp#实现"><span>实现</span></a></li><li title="解耦一些思路" data-depth="2"><a href="/summary/mvp#解耦一些思路"><span>解耦一些思路</span></a></li><li title="引入拦截器" data-depth="3"><a href="/summary/mvp#引入拦截器"><span>引入拦截器</span></a></li><li title="继承" data-depth="3"><a href="/summary/mvp#继承"><span>继承</span></a></li><li title="总结" data-depth="2"><a href="/summary/mvp#总结"><span>总结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="我在前端项目中使用了-mvp"><a aria-hidden="true" tabindex="-1" href="/summary/mvp#我在前端项目中使用了-mvp"><span class="icon,icon-link"></span></a>我在前端项目中使用了 MVP</h1><p>如今流行的 React、Vue 等框架以及微信小程序都会将视图层和数据层抽离，提供组件化的开发模式，解耦交互逻辑，实现了代码的复用。那么 MVC 在前端领域还有再提及的必要吗？</p><p>有的，React 只当作自己是 ui render 函数，可以看作 MVC 中的 V。本文介绍 MVC 的变种 - MVP 设计思想，实践于一个交互复杂的微信小程序，在此作总结回顾。</p><h2 id="概述"><a aria-hidden="true" tabindex="-1" href="/summary/mvp#概述"><span class="icon,icon-link"></span></a>概述</h2><h3 id="mvp-简介"><a aria-hidden="true" tabindex="-1" href="/summary/mvp#mvp-简介"><span class="icon,icon-link"></span></a>MVP 简介</h3><p><img src="/static/passive-view.befb08e1.png" alt="passive-view"/></p><p>相信大家都了解 MVC 的开发模式，其主要解决视图、数据、业务逻辑耦合度较高；视图、数据模型无法复用；无法进行单元测试，保证代码质量。MVP 是 MVC 的延伸，<strong>MVP 与 MVC 的区别在于 Model 层和 View 层的解耦</strong> ，在 MVC 的基础上，它强调强视图和模型层分离，这样的好处也是显而易见的：Model 的职责更加单一，且不与视图层耦合；View 层也更加的“函数式”，减少因与模型层耦合带来的副作用，更加利于组件化。</p><blockquote><p>如果对 MVC、MVP、MVVM 概念还有模糊的同学，可以参考 <a target="_blank" rel="noopener noreferrer" href="https://draveness.me/mvx/">浅谈 MVC、MVP 和 MVVM 架构模式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote><h3 id="背景"><a aria-hidden="true" tabindex="-1" href="/summary/mvp#背景"><span class="icon,icon-link"></span></a>背景</h3><p>前端应用随着项目的复杂度的提升，以下问题逐渐暴露：</p><ol><li><p>视图层没有明确的职责划分，绝大部分业务逻辑会在视图层完成，视图层会变得越来越臃肿</p><p>一个 vue 组件几百上千行代码，充满业务逻辑</p></li><li><p>业务逻辑无法复用</p><p>一种业务逻辑在 N 个页面实现了 N 遍</p></li><li><p>视图层和业务逻辑耦合较高，单元测试难度大，覆盖率不高</p></li><li><p>没有清晰的架构分层</p></li></ol><h2 id="实践"><a aria-hidden="true" tabindex="-1" href="/summary/mvp#实践"><span class="icon,icon-link"></span></a>实践</h2><h3 id="需求"><a aria-hidden="true" tabindex="-1" href="/summary/mvp#需求"><span class="icon,icon-link"></span></a>需求</h3><p>假如产品经理给我们这样一个需求：</p><ul><li>渲染多个分类 Radio，这些按钮需要写在数据库里，能随时增加减少</li><li>由于可能存在多个，默认只显示部分，其余部分点击更多展示</li><li>五秒钟之后没有选择，自动收起</li></ul><p>相信你看完已经有自己的思路，那么如果以 MVP 的思路实现，会是怎样的？</p><h3 id="实现"><a aria-hidden="true" tabindex="-1" href="/summary/mvp#实现"><span class="icon,icon-link"></span></a>实现</h3><h4 id="view-视图层"><a aria-hidden="true" tabindex="-1" href="/summary/mvp#view-视图层"><span class="icon,icon-link"></span></a>View 视图层</h4></div><div class="__dumi-default-previewer" id="mvp_code-view"><div class="__dumi-default-previewer-demo"><section><div class="ant-radio-group ant-radio-group-outline"><label class="ant-radio-wrapper"><span class="ant-radio"><input type="radio" class="ant-radio-input" value="1"/><span class="ant-radio-inner"></span></span><span>茶水间</span></label><label class="ant-radio-wrapper"><span class="ant-radio"><input type="radio" class="ant-radio-input" value="2"/><span class="ant-radio-inner"></span></span><span>文印室</span></label><label class="ant-radio-wrapper"><span class="ant-radio"><input type="radio" class="ant-radio-input" value="3"/><span class="ant-radio-inner"></span></span><span>卫生间</span></label><button type="button" class="ant-btn ant-btn-link"><span>展开</span></button></div></section></div><div class="__dumi-default-previewer-desc" data-title="View"><a href="/summary/mvp#mvp_code-view">View</a><div><div class="markdown"><p>接受 source、onChange、onCollapse 三个参数</p></div></div></div><div class="__dumi-default-previewer-actions"><a target="_blank" rel="noopener noreferrer" href=""><button title="Open demo in new tab" class="__dumi-default-icon" role="open-demo" type="button"></button></a><span></span><button title="Copy source code" class="__dumi-default-icon" role="copy" data-status="ready"></button><button title="Toggle source code panel" class="__dumi-default-icon" role="source" type="button"></button></div></div><div class="markdown"><p>在编写视图部分源码中，要遵守一个原则：视图层仅做数据接受与事件发送，绝不参杂任何业务逻辑。</p><h4 id="presenter-业务逻辑层"><a aria-hidden="true" tabindex="-1" href="/summary/mvp#presenter-业务逻辑层"><span class="icon,icon-link"></span></a>Presenter 业务逻辑层</h4><p>再来看看经 presenter 剥离的代码逻辑是怎样的：</p></div><div class="__dumi-default-previewer" id="mvp_code-presenter_view"><div class="__dumi-default-previewer-demo"><section><div class="ant-radio-group ant-radio-group-outline"><label class="ant-radio-wrapper"><span class="ant-radio"><input type="radio" class="ant-radio-input" value="1"/><span class="ant-radio-inner"></span></span><span>茶水间</span></label><label class="ant-radio-wrapper"><span class="ant-radio"><input type="radio" class="ant-radio-input" value="2"/><span class="ant-radio-inner"></span></span><span>文印室</span></label><label class="ant-radio-wrapper"><span class="ant-radio"><input type="radio" class="ant-radio-input" value="3"/><span class="ant-radio-inner"></span></span><span>卫生间</span></label><button type="button" class="ant-btn ant-btn-link"><span>展开</span></button></div></section></div><div class="__dumi-default-previewer-desc" data-title="View + Presenter"><a href="/summary/mvp#mvp_code-presenter_view">View + Presenter</a><div><div class="markdown"><p>presenter 层处理业务逻辑</p></div></div></div><div class="__dumi-default-previewer-actions"><a target="_blank" rel="noopener noreferrer" href=""><button title="Open demo in new tab" class="__dumi-default-icon" role="open-demo" type="button"></button></a><span></span><button title="Copy source code" class="__dumi-default-icon" role="copy" data-status="ready"></button><button title="Toggle source code panel" class="__dumi-default-icon" role="source" type="button"></button></div></div><div class="markdown"><p>Presenter 主要用来处理业务逻辑，接受视图抛出的事件并处理与 model 层等其他模块的交互。有人可能会说：这样做看起来只是将 view 层的代码转移到了 presenter 层而已，肯定又会导致 presenter 层业务逻辑较重。</p><p>其实不然，这中间是有收益的：视图层与业务逻辑分离，这点很重要，这样意味着我们才能够开始通过各种设计模式来解耦、复用业务逻辑。例如，presenter 是用 class 方式实现的，如果另一个页面组件也需要依赖相同的逻辑，通过简单的继承就可以实现复用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token keyword">class</span><span class="token plain"> </span><span class="token class-name">OtherPresenter</span><span class="token plain"> </span><span class="token keyword">extends</span><span class="token plain"> </span><span class="token class-name">RadioViewPresenter</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">option</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token plain">option</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// other methods</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><h4 id="model-数据层"><a aria-hidden="true" tabindex="-1" href="/summary/mvp#model-数据层"><span class="icon,icon-link"></span></a>Model 数据层</h4><p>Model 层用来获取数据，这里引入一种实体的概念来抽象业务的逻辑，以便与解耦部分 presenter 中的逻辑。</p></div><div class="__dumi-default-previewer" id="mvp_code-model_presenter_view"><div class="__dumi-default-previewer-demo"><section><div class="ant-radio-group ant-radio-group-outline"><button type="button" class="ant-btn ant-btn-link"><span>展开</span></button></div></section></div><div class="__dumi-default-previewer-desc"></div><div class="__dumi-default-previewer-actions"><a target="_blank" rel="noopener noreferrer" href=""><button title="Open demo in new tab" class="__dumi-default-icon" role="open-demo" type="button"></button></a><span></span><button title="Copy source code" class="__dumi-default-icon" role="copy" data-status="ready"></button><button title="Toggle source code panel" class="__dumi-default-icon" role="source" type="button"></button></div></div><div class="markdown"><h2 id="解耦一些思路"><a aria-hidden="true" tabindex="-1" href="/summary/mvp#解耦一些思路"><span class="icon,icon-link"></span></a>解耦一些思路</h2><p>上面提到，随着业务逻辑逐渐复杂 presenter 的业务逻辑会业务逻辑会越来越多，应用一些软件工程的设计模式会可以更高效、更灵活的解决实际问题。</p><h3 id="引入拦截器"><a aria-hidden="true" tabindex="-1" href="/summary/mvp#引入拦截器"><span class="icon,icon-link"></span></a>引入拦截器</h3><p>拦截器可以在 MVP 的分层模型中增加一个切面，这样可以很在不改变原来的流程中，引入一些自定义逻辑，如日志上报、鉴权等。</p><p>现在又接到了产品经理的一个需求:</p><ul><li>搜索页面中，对输入的关键词进行上报</li><li>搜索结果中，对用户选择的结果项进行上报</li></ul><p><img src="/static/image-20200730221105855.9292eb4b.png" alt="image-20200730221105855"/></p><p>假设搜索页面就是以 MVP 的方式开发的，那么增加这个上报逻辑会很简单：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token keyword">class</span><span class="token plain"> </span><span class="token class-name">SearchViewPresenter</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  @</span><span class="token function">applyAOPDecorator</span><span class="token punctuation">(</span><span class="token plain">report</span><span class="token punctuation">)</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token function">onSearch</span><span class="token punctuation">(</span><span class="token parameter">keyword</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;onSearch&quot;</span><span class="token punctuation">,</span><span class="token plain"> keyword</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain">  @</span><span class="token function">applyAOPDecorator</span><span class="token punctuation">(</span><span class="token plain">report</span><span class="token punctuation">)</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token function">onChoose</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;onChoose&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">applyAOPDecorator</span><span class="token punctuation">(</span><span class="token parameter">interceptor</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">return</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token parameter punctuation">,</span><span class="token parameter"> name</span><span class="token parameter punctuation">,</span><span class="token parameter"> descriptor</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token arrow operator">=&gt;</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">const</span><span class="token plain"> func </span><span class="token operator">=</span><span class="token plain"> descriptor</span><span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    descriptor</span><span class="token punctuation">.</span><span class="token method-variable function-variable method function property-access">value</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token keyword">function</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token parameter operator">...</span><span class="token parameter">args</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token function">report</span><span class="token punctuation">(</span><span class="token spread operator">...</span><span class="token plain">args</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      func</span><span class="token punctuation">.</span><span class="token method function property-access">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">report</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// ajax report</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p>基于 AOP 的编程思想，配合 MVP 分层模型，几乎不需要改动源代码就可以实现上报逻辑的接入。</p><p>这里说句题外话，上面 AOP 基于 ECMAScript 的提案 decorator 来实现的，该语法现在已经被大幅度修改，阮一峰老师的 <a target="_blank" rel="noopener noreferrer" href="https://es6.ruanyifeng.com/#docs/decorator">ECMAScript 6 入门<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中关于 decorator 的讲解基本已经不可参考了。如果你也想在项目中实现 AOP 切面编程，需要基于 js 继承和原型链来实现 AOP。</p><h3 id="继承"><a aria-hidden="true" tabindex="-1" href="/summary/mvp#继承"><span class="icon,icon-link"></span></a>继承</h3><p>观察下面路线规划和导航页面的截图，这两个页面中，画线、绘制 marker 、楼层切换等很多交互逻辑基本相同，而两者的复用直接通过类的继承就可以解决：</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token keyword">class</span><span class="token plain"> </span><span class="token class-name">NavPresenter</span><span class="token plain"> </span><span class="token keyword">extends</span><span class="token plain"> </span><span class="token class-name">RouteplanPresenter</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span></div></pre></div><p><img src="/static/nav.a33a60b2.png" alt="nav"/></p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/summary/mvp#总结"><span class="icon,icon-link"></span></a>总结</h2><p>MVP 应用于小程序的开发模式中，其主要职责在于解耦 视图、数据、业务逻辑间的依赖关系，借助实体、AOP 等编程思想，极大的提高了业务的灵活性、可拓展性。</p></div><div class="__dumi-default-layout-footer-meta"><span data-updated-text="Last update: ">2021-1-6 21:24:15</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="https://hm.baidu.com/hm.js?56fbe606b14d07f8ad321f2c766e4d29"></script>
    <script src="/umi.af893a71.js"></script>
  </body>
</html>
